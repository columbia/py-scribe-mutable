#!/usr/bin/python

import scribe
import sys
import mmap
import signal
from optparse import OptionParser

# Send a SIGUSR1 signal to go live when it can

def main():
    usage = 'usage: %prog [options] log_file'
    desc = 'Replay a previously recorded execution.'
    parser = OptionParser(usage=usage, description=desc)

    parser.add_option('-b', '--backtrace', dest='backtrace_len',
            metavar='LEN', type='int', default=100,
            help='Specify the maximum number of entries in the backtrace. ' \
                 'The default is 100.')
    parser.add_option("-d", "--dmesg",
            action="store_true", dest="dmesg", default=False,
            help='Show a dmesg trace if the replay diverges')
    parser.add_option('-g', '--golive', dest='golive_bookmark_id',
            metavar='BOOKMARK_ID', type='int', default=None,
            help='Specify a specific bookmark to go live with')

    (options, args) = parser.parse_args()
    if not args:
        parser.error('Give me a log file')
    if len(args) > 2:
        parser.error('You have extra arguments')
    logfile = open(args[0], 'r')

    ps = scribe.Popen(logfile, replay = True, show_dmesg = options.dmesg,
                      backtrace_len = options.backtrace_len,
                      golive_bookmark_id = options.golive_bookmark_id)

    stop_requested = [False]
    def do_stop(signum, stack):
        try:
            ps.stop()
            stop_requested[0] = True
        except OSError as e:
            print("Cannot request to stop (%s)" % str(e), file=sys.stderr)
    signal.signal(signal.SIGUSR1, do_stop)

    ps.scribe_wait()
    if stop_requested[0] or options.golive_bookmark_id:
        print("Replay stopped", file=sys.stderr)
    ps.wait()

if __name__ == '__main__':
    main()
